name: react-antd-dva
git_url: 'git://github.com/sosout/react-antd-dva.git'
author: sosout
description: 基于react + ant-design + dva + Mock 企业级后台管理系统最佳实践
tags:
  - dva
  - react
  - ant-design
  - 'Mock '
  - webpack
coverPicture: 'https://ucarecdn.com/21123acc-2d3d-4009-aac3-0a5728854fda/'
readme: "# react-antd-dva\n\n基于react + ant-design + dva + Mock 企业级后台管理系统最佳实践\n\n## 特性\n\n- :gem: **优雅美观**：基于 Ant Design 体系精心设计\n- :rocket: **最新技术栈**：使用 React/dva/antd 等前端前沿技术开发\n- :1234: **Mock 数据**：实用的本地数据调试方案\n\n## 模板\n\n- [x] 项目搭建\n- [x] 登录\n- [ ] 主页\n\n## 使用\n\n```bash\n$ git clone https://github.com/sosout/react-antd-dva.git\n$ cd react-antd-dva\n$ npm install\n$ npm start         # 访问 http://localhost:8888\n```\n\n## 兼容性\n\n现代浏览器及 IE11。\n\n\n## dva用法\n\n### dynamic\n\n解决组件动态加载问题的 util 方法，基于 react-async-component 实现。比如：\n\n```javascript\nimport dynamic from 'dva/dynamic';\n\nconst UserPageComponent = dynamic({\n  app,\n  models: () => [\n    import('./models/users'),\n  ],\n  component: () => import('./routes/UserPage'),\n});\n```\n\n## react-router 4.0\n\n### exact（boolean类型）\n\n如果为 true, 则仅在位置完全匹配时才应用。\n\n```javascript\npath\tlocation.pathname\texact\tmatches?\n/one\t/one/two\t        true\tno\n/one\t/one/two\t        false\tyes\n```\n\n## React PureComponent\n\n### 为什么使用？\n\nReact15.3中新加了一个 PureComponent 类，顾名思义， pure 是纯的意思， PureComponent 也就是纯组件，取代其前身 PureRenderMixin , PureComponent 是优化 React 应用程序最重要的方法之一，易于实施，只要把继承类从 Component 换成 PureComponent 即可，可以减少不必要的 render 操作的次数，从而提高性能，而且可以少写 shouldComponentUpdate 函数，节省了点代码。\n\n### 原理\n\n当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较：\n\n```javascript\nif (this._compositeType === CompositeTypes.PureClass) {\n  shouldUpdate = !shallowEqual(prevProps, nextProps)\n  || !shallowEqual(inst.state, nextState);\n}\n````\n\n而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key 是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。\n\n### 使用指南\n\n#### 易变数据不能使用一个引用\n\n示例：\n\n```javascript\nclass App extends PureComponent {\n  state = {\n    items: [1, 2, 3]\n  }\n  handleClick = () => {\n    const { items } = this.state;\n    items.pop();\n    this.setState({ items });\n  }\n  render() {\n    return (<div>\n      <ul>\n        {this.state.items.map(i => <li key={i}>{i}</li>)}\n      </ul>\n      <button onClick={this.handleClick}>delete</button>\n    </div>)\n  }\n}\n```\n\n会发现，无论怎么点 delete 按钮， li 都不会变少，因为 items 用的是一个引用， shallowEqual 的结果为 true 。改正：\n\n```javascript\nhandleClick = () => {\n  const { items } = this.state;\n  items.pop();\n  this.setState({ items: [].concat(items) });\n}\n```\n\n这样每次改变都会产生一个新的数组，也就可以 render 了。这里有一个矛盾的地方，如果没有 items.pop(); 操作，每次 items 数据并没有变，但还是 render 了，这不就很操蛋么？呵呵，数据都不变，你 setState 干嘛？\n\n#### 不变数据使用一个引用\n\n##### 子组件数据\n\n上面易变数据不能使用一个引用的案例中有一个点击删除操作，如果我们删除的代码这么写：\n\n```javascript\nhandleClick = () => {\n  const { items } = this.state;\n  items.splice(items.length - 1, 1);\n  this.setState({ items });\n}\n```\n\nitems 的引用也是改变的，但如果 items 里面是引用类型数据：\n\n```javascript\nitems: [{a: 1}, {a: 2}, {a: 3}]\n```\n\n这个时候\n\n```javascript\nstate.items[0] === nextState.items[0] // false\n```\n\n子组件里还是re-render了。这样就需要我们保证不变的子组件数据的引用不能改变。这个时候可以使用immutable-js函数库。\n\n##### 函数属性\n\n我们在给组件传一个函数的时候，有时候总喜欢:\n\n```javascript\n// 1\n<MyInput onChange={e => this.props.update(e.target.value)} />\n// 2\nupdate(e) {\n  this.props.update(e.target.value)\n}\nrender() {\n  return <MyInput onChange={this.update.bind(this)} />\n}\n```\n\n由于每次 render 操作 MyInput 组件的 onChange 属性都会返回一个新的函数，由于引用不一样，所以父组件的 render 也会导致 MyInput 组件的 render ，即使没有任何改动，所以需要尽量避免这样的写法，最好这样写：\n\n```javascript\n// 1,2\nupdate = (e) => {\n  this.props.update(e.target.value)\n}\nrender() {\n  return <MyInput onChange={this.update} />\n}\n```\n\n##### 空对象、空数组或固定对象\n\n有时候后台返回的数据中，数组长度为0或者对象没有属性会直接给一个 null ，这时候我们需要做一些容错：\n\n```javascript\nclass App extends PureComponent {\n  state = {\n    items: [{ name: 'test1' }, null, { name: 'test3'  }]\n  }\n  store = (id, value) => {\n    const { items } = this.state;\n    items[id]  = assign({}, items[id], { name: value });\n    this.setState({ items: [].concat(items) });\n  }\n  render() {\n    return (<div>\n      <ul>\n        {this.state.items.map((i, k) =>\n          <Item style={{ color: 'red' }} store={this.store} key={k} id={k} data={i || {}} />)\n        }\n      </ul>\n    </div>)\n  }\n}\n```\n\n当某一个子组件调用 store 函数改变了自己的那条属性，触发 render 操作，如果数据是 null 的话 data 属性每次都是一个 {}，{} ==== {} 是 false 的，这样无端的让这几个子组件重新 render 了。{ color: 'red' }也是一样。\n\n最好设置一个 defaultValue 为 {},如下：\n\n```javascript\nstatic defaultValue = {}\nconst style = { color: 'red' };\n<Item style={style} store={this.store} key={k} id={k} data={i || defaultValue} />\n```\n\n### 复杂状态与简单状态不要共用一个组件\n\n这点可能和 PureComponent 没多少关系，但做的不好可能会浪费很多性能，比如一个页面上面一部分是一个复杂的列表，下面是一个输入框，抽象代码：\n\n```javascript\nchange = (e) => {\n  this.setState({ value: e.target.value });\n}\nrender() {\n  return (<div>\n    <ul>\n      {this.state.items.map((i, k) => <li key={k}> {...}</li>)}\n    </ul>\n    <input value={this.state.value} onChange={this.change} />\n  </div>)\n}\n```\n\n表单和列表其实是没有什么关联的，表单的值也可能经常变动，但它的会给列表也带来必然的 diff 操作，这是没必要的，最好是给列表抽出成一个单独的 PureComponent 组件，这样 state.items 不变的话，列表就不会重新 render 了。\n\n### 与 shouldComponentUpdate 共存\n\n如果 PureComponent 里有 shouldComponentUpdate 函数的话，直接使用 shouldComponentUpdate 的结果作为是否更新的依据，没有 shouldComponentUpdate 函数的话，才会去判断是不是 PureComponent ，是的话再去做 shallowEqual 浅比较。\n\n```javascript\n// 这个变量用来控制组件是否需要更新\nvar shouldUpdate = true;\n// inst 是组件实例\nif (inst.shouldComponentUpdate) {\n  shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);\n} else {\n  if (this._compositeType === CompositeType.PureClass) {\n    shouldUpdate = !shallowEqual(prevProps, nextProps) ||\n      !shallowEqual(inst.state, nextState);\n  }\n}\n```\n\n### 老版本兼容写法\n\n```javascript\nimport React { PureComponent, Component } from 'react';\nclass Foo extends (PureComponent || Component) {\n  //...\n}\n```\n\n这样在老版本的 React 里也不会挂掉。\n\n### 总结\n\nPureComponent 真正起作用的，只是在一些纯展示组件上，复杂组件用了也没关系，反正 shallowEqual 那一关就过不了，不过记得 props 和 state 不能使用同一个引用哦。\n"
deployedAt: 2017-12-08T10:02:29.375Z
